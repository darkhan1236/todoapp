from sqlalchemy import ForeignKey, String, BigInteger
from sqlalchemy.orm import Mapped, DeclarativeBase, mapped_column
from sqlalchemy.ext.asyncio import AsyncAttrs, async_sessionmaker, create_async_engine

'''
Чтобы база данных работала нам надо ее создать и к ней подключиться, поэтому пишем create_async_engine и в скобках должны написать url адрес,
но так как мы используем не серверную субд а файловую такую как sqlite мы прописываем во первых сам диалект это у нас sqlite дальше db который используется для общения,
А у нас db api он асинхронный aiosqlite дальше здесь нужно прописать путь но вместо пути я прописываю название файла. Кроме этого сюда можно добавить дополнительный аргумент 
который называется echo=True то есть благодаря нему мы будем видеть на терминале логирование, что происходит в процессе пользования sqlalchemy
'''
engine = create_async_engine(url="sqlite+aiosqlite:///db.sqlite3", echo=True)

'''
Создадим асинхронную сессию, сессия используется для того чтобы в этой базе данных уже делать изменения то есть сверху мы ее создали к ней подключились, а сейчас с помощью sessionmaker
мы уже деалем запросы в определенную базу данных какую, которую мы ранее создали и записали в переменную engine. А также мы сюда добавим expire_on_commit=False для того чтобы когда мы сделаем изменения сессия не закрывалась
'''
async_session = async_sessionmaker(bind=engine, expire_on_commit=False)

'''
после того как мы подключились мы можем сделать изменения, давайте теперь пропишем те самые сущности, для того чтобы с ними работать нужно создать класс Base. Этот класс Base будет заниматься управлением всеми отдельными оставшимися классами которые мы
далее напишем
'''

class Base(AsyncAttrs, DeclarativeBase):
    pass


# А именно мы напишем класс User - это сущность пользователя.
class User(Base):
    # таблица у нас будет называться users
    '''класс называется на един. числе а таблица называется во множественном числе. Почему? Потому что с помощью класса мы описываем одного пользователя мы описываем сущность одного человека а вот в таблице будет храниться этих сущностей много поэтому они соответственно называются во множественном '''
    __tablename__ = 'users'
    
    '''снизу значит что у каждого пользователя будет свой уникальный id, он будет храниться в виде integer то есть это будет целое число и это число будет главным ключом если вы знаете о том как устроены базы данных то обязательно должен быть какой то идентификатор чаще всего это как раз есть таки ID'''
    id: Mapped[int] = mapped_column(primary_key=True)
    
    '''Но так как мы делаем приложение для tg нам нужно этого каждого пользователя идентифицировать и как бы синхронизировать его аккаунт с его tg аккаунтом. Поэтому мы объязаны кроме Id который мы создали в своей системе а также прописать сюда tg id к какому пользвоателю этот аккаунт относится. Но мы здесь не прописали Mapped то есть здесь нету такой 
    такой типизации, тип прописан в mapped_column c названием BigInteger почему, потому что встроенного типа biginteger в пайтоне не существует поэтому я его прописываю отдельно 
    '''
    tg_id = mapped_column(BigInteger)
    
    
class Task(Base):
    __tablename__ = 'tasks'
    
    id: Mapped[int] = mapped_column(primary_key=True)
    '''Mapped[str] Это аннотация типа (type hint). Mapped[...] говорит SQLAlchemy: «это поле будет связано с колонкой в базе данных».
    str внутри скобок указывает тип Python-объекта, который будет храниться (в БД это строка, в коде — str). 2. mapped_column(...) Это уже функция, которая создаёт саму колонку в таблице.
    В скобках мы указываем тип колонки в БД (String(128) = строка длиной до 128 символов).'''
    title: Mapped[str] = mapped_column(String(128))
    # снизу мы будем отмечать что эта задача выполнена или нет 
    completed: Mapped[bool] = mapped_column(default=False)
    user: Mapped[int] = mapped_column(ForeignKey('users.id', ondelete='CASCADE'))
    

'''
создали асинхронную функцию init_db, и подключаясь к этой базе данных мы запустили синхронизацию и с помощью класса Base который является родительским по отношению ко всем остальным, и с помощью него
создали все эти таблицы. То есть при запуске Бота мы всегда будем вызывать эту функцию для того чтобы все таблицы создались. Если мы сделали какие то корректировки в базу данных то нам нужно использовать такой фреймворк как alembic 
для того чтобы сделать миграции и соответственно внести корректировки. Если мы просто добавили новую таблицу то тогда вот этого run_sync вполне достаточно.
'''
# Асинхронность позволяет не блокировать весь сервер, пока создаётся соединение/таблицы.
async def init_db():
    # engine.begin() → открывает транзакцию (то есть «сессию работы» с БД).
    async with engine.begin() as conn:
        '''Base.metadata.create_all - Это обычная синхронная функция SQLAlchemy. Она сама по себе не умеет работать в async.Делает SQL-команды CREATE TABLE ... для всех моделей.
        conn.run_sync(...) - Это «мостик» (адаптер), чтобы запустить синхронную функцию внутри асинхронного кода.await Мы ждём, пока всё это выполнится.Если не поставить await, код пойдёт дальше, не дождавшись создания таблиц.'''
        await conn.run_sync(Base.metadata.create_all)
        
        